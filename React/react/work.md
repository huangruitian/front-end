## react 
- 调度器 + 渲染器
- jsx，react决定使用jsx来渲染UI，就要决绝以下两个问题
1. 输入JSX后，我们如何解析JSX，并决定哪些是需要最终渲染成DOM节点？
2. 我们怎么把需要渲染的DOM元素渲染到页面上？
- React给出的解答是：将整个流程分为**调度**和**渲染**两个部分。

1. 调度器
- 负责解析jsx，计算出哪些节点需要渲染，整理出要渲染的节点
2. 渲染器
- 收到**调度器**的通知，把调度器整理好的节点渲染到页面上

## 为什么需要调度器
- 设想以下场景：有一个地址搜索框，在输入字符时会实时请求当前已输入内容的地址匹配结果。
- 这里包括2个状态变化：
1. 我们希望用户输入的字符能实时显示在输入框内，不能有卡顿。
2. 下拉框内容有个加载的过程一般是可以接受的。
- 所以当同时触发这两个状态变化时1的优先级如果能高于2那用户体验想必是更好的。
- 甚至极端的考虑，我们已经触发了2，在计算2需要改变的DOM节点的过程中用户又触发了1，这时候如果能搁置2转而优先处理场景1，这种体验是符合预期的。
- 这就是我们叫他调度器的原因——决定要处理什么，以及调度他们的优先级。
- 当调度器已经处理好需要渲染的节点，为什么不直接渲染呢，而需要渲染器？

## 为什么需要渲染器
- 因为React的野心从来不仅限于web端，理论上当调度器整理出的节点应用于不同渲染器，就能实现在不同平台的渲染。

## 调度最小的单元 Fiber
要实现React的宏伟愿景，还有2个小问题：
1. 由于调度器能对应多个平台的渲染器，那调度器调度的节点就不能是平台相关的。如果调度器调度出的节点都是DOM节点，显然这些节点是没法在Native环境被渲染器渲染的。所以我们需要一种平台无关的节点结构。
2. 刚才讲到调度器的功能时，我们希望低优先级的调度是可以被终止以重新开始一个更高优先级的调度的。那么被调度的节点粒度一定要够细，这样我们才能完全操控节点终止调度的位置并清除之前调度产生的结果再重新开始。
- 为了解决这2个问题，React提出了一种名叫Fiber的结构
- 我们可以在Fiber节点中保存节点的类型（比如App节点是一个函数组件节点，div节点是一个原生DOM节点，I am节点是一个文本节点），可以保存节点对应的state,props，可以保存节点对应的值（比如App节点对应左侧的函数，div节点对应div DOMElement）。
- 这样的结构也解释了为什么函数组件（React Hooks）可以保存state。因为state并不是保存在函数上，而是保存在函数组件对应的Fiber节点上。

- 对于Fiber的结构其实我们可以更进一步。我们为Fiber增加如下字段：
1. child：指向第一个子Fiber
2. sibling：指向右边的兄弟节点
- 这样我们的父Fiber节点不需要用数组的形式保存多个子节点。

## 调度和渲染的整体流程
- 现在有了可供调度的节点类型（Fiber），可以愉快的开始第一次调度辣。
- 整个调度阶段需要做2件事：
1. 向下遍历JSX，为每个节点的子节点生成对应的Fiber，并赋值
- effectTag字段表示当前Fiber需要执行的副作用，最常见的副作用是：
- Placement 插入DOM节点
- Update 更新DOM节点
- Deletion 删除DOM节点
- 当然，首屏渲染只会涉及到Placement。

2. 为每个Fiber生成对应的DOM节点，保存在Fiber.stateNode。

- 做完这2件事后我们通知渲染器，此时渲染器知道
1. 哪些 Fiber 需要执行哪些操作（由Fiber.effectTag得知）
2. 执行这些操作的Fiber他们对应的DOM节点（由Fiber.stateNode得知）
- 有了这些数据，渲染器只需要遍历所有有Placement副作用的Fiber，依次执行DOM插入操作就完成了首屏的渲染。这就是首屏调度+渲染的整个过程。机智如你，是不是理解起来完全没压力呢。

调度阶段会做的两个事情
## beginWork
- 向下遍历JSX，为每个节点的子节点生成对应的Fiber，并设置effectTag
- 我们叫他beginWork，这是每个节点调度阶段开始工作的起点。
## completeWork
- 为每个Fiber生成对应的DOM节点
- 我们叫他completeWork，这是每个节点调度阶段完成工作的终点。

## workInProgress
- 我们通过workInProgress这个全局变量表示当前render阶段正在处理的Fiber，当首屏渲染初始化时， workInProgress === 根Fiber，接着我们调用workLoopSync方法，他内部会循环调用performUnitOfWork方法，这个方法接收当前workInProgress传入，处理他，返回下一个需要处理的Fiber。

- 在performUnitOfWork函数内部，会执行刚才我们讲到的beginWork，创建并返回当前Fiber的子Fiber。当没有返回子Fiber，意味着遍历到最内层的节点，

