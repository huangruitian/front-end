

## 网络通讯方式
1. 单工通讯：数据只在一个方向上传输，不能实现双方通信，例如：电视、广播；
2. 半双工通讯：允许数据在两个方向上传输，但是同一时间数据只能在一个方向上传输，其实际上是切换的单工，例如：对讲机。
3. 全双工通讯：允许数据在两个方向上同时传输，例如：手机通话。

## URI 和 URL
- URL:统一资源定位符（Uniform Resource Locator）。URL正是使用 Web 浏览器等
访问 Web 页面时需要输入的网页地址。比如， http://hackr.jp/ 就是 URL。
- URI:统一资源标识符，URI 用字符串标识某一互联网资源，而URL表示资源的地点（互联
网上所处的位置）。可见 URL是 URI 的子集。
- http 协议是遵照由 RFC 确定的标准来实现的，因为要统一规范才能实现通讯；否则会出现通讯双方无法通讯的问题；

## http协议用于客户端和服务器端之间的通信
- 必须是由客户端发送，服务端响应的方式，简单的轮询

## http是无状态协议
- 使用 HTTP 协议，每当有新的请求发送时，就会有对应的新响应产生。
- 协议本身并不保留之前一切的请求或响应报文的信息。这是为了更快地处理大量事务，确保协议的可伸缩性，
- 而特意把 HTTP 协议设计成如此简单的。

## 告知服务器意图的 HTTP/1.1 方法
1. GET：获取资源
- 方法用来请求访问已被 URI（URL） 识别的资源。指定的资源经服务器端解析后返回响应内容。 
2. POST：传输实体主体
- 虽然用 GET 方法也可以传输实体的主体，但一般不用 GET 方法进行传输，而是用 POST 方法。
- 虽说 POST 的功能与 GET 很相似，但 POST 的主要目的并不是获取响应的主体内容。
3. PUT：传输文件
- PUT 方法用来传输文件。鉴于 HTTP/1.1 的 PUT 方法自身不带验证机制，任何人都可以
上传文件 , 存在安全性问题，因此一般的 Web 网站不使用该方法。
4. HEAD：获得报文首部
- HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于确认URI 的有效性及资源更新的日期时间等。
5. DELETE：删除文件
- 和PUT一样，一般都不会用
6. OPTIONS：询问支持的方法
- OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。
7. TRACE：追踪路径
- TRACE 方法是让 Web 服务器端将之前的请求通信环回给客户端的方法。TRACE 方法就是用来确认连接过程中发生的一系列操作。
- 但是，TRACE 方法本来就不怎么常用，再加上它容易引发 XST（Cross-Site Tracing，跨站追踪）攻击，通常就更不会用到了。
8. CONNECT：要求用隧道协议连接代理
- CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加 密后经网络隧道传输。

## 持久连接（keep-alive）节省通信量
- HTTP 协议的初始版本（0.9）中，每进行一次 HTTP 通信就要断开一次 TCP连接。
- 为解决上述 TCP 连接的问题，HTTP/1.1 和一部分的 HTTP/1.0 想出了持久连接（HTTP Persistent Connections，
也称为 HTTP keep-alive 或HTTP connection reuse）的方法。持久连接的特点是，只要任意一端
没有明确提出断开连接，则保持 TCP 连接状态。
- 在 HTTP/1.1 中，所有的连接默认都是持久连接；1.0的时候不是默认的；

## 管线化
- 持久连接使得多数请求以管线化（pipelining）方式发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。
- 这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。
- 比如，当请求一个包含 10 张图片的 HTMLWeb 页面，与挨个连接相比，用持久连接可以让请求更快结束。而管线化技术则比持久连接还
要快。请求数越多，时间差就越明显。（但是还是以队头阻塞的方式进行请求）

## 使用 Cookie 的状态管理
- 服务的返回set-Cookie，客户端每次就可以带上它，就可以达到持久化状态；

## HTTP报文
- 报文首部 + 空行 + 报文主体

## 压缩传输的内容编码
1. gzip（GNU zip）
2. compress（UNIX 系统的标准压缩）
3. identity（不进行编码）

## 分割发送的分块传输编码
- 在 HTTP 通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。
- 在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。
- 这种把实体主体分块的功能称为分块传输编码（Chunked Transfer Coding）。

## 发送多种数据的多部分对象集合
- multipart/form-data 在 Web 表单文件上传时使用。
- multipart/byteranges 状态码 206（Partial Content，部分内容）响应报文包含了多个范围的内容时使用。
- multipart/form-data 上传文件时的格式
...等等

## 获取部分内容的范围请求
- 在网络环境差的时候，比如下载一个图片，完成99%了，最后1%掉线了。
- 如果重新下载那会非常的难受，会用到首部字段 Range 来指定资源的 byte 范围。区域下载剩下的

## HTTP状态码
1. 1XX  Informational（信息性状态码）    接收的请求正在处理
2. 2XX  Success（成功状态码）            请求正常处理完毕     
3. 3XX  Redirection（重定向状态码）      需要进行附加操作以完成请求
4. 4XX  Client Error（客户端错误状态码）  服务器无法处理请求
5. 5XX  Server Error（服务器错误状态码）  服务器处理请求出错
- 只要遵守状态码类别的定义，即使改变 RFC2616 中定义的状态码，或服务器端自行创建状态码都没问题。
- 别看种类繁多，实际上经常使用的大概只有 14 种。
1. 200 OK 
- 表示从客户端发来的请求在服务器端被正常处理了。
2. 204 No Content 
- 该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。
- 另外，也不允许返回任何实体的主体。比如，当从浏览器发出请求处理后，返回 204 响应，那么浏览器显示的页面不发生更新。
3. 206 Partial Content
- 该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET 请求。
- 响应报文中包含由 Content-Range 指定范围的实体内容。
4. 301 Moved Permanently
- 永久性重定向。该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。
5. 302 Found
- 临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。
6. 303 See Other
- 该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。
7. 304 Not Modified
- 该状态码表示客户端发送附带条件的请求 2 时，服务器端允许请求访问资源，但未满足条件的情况。
- 304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系。
8. 307 Temporary Redirect
- 临时重定向。该状态码与 302 Found 有着相同的含义。尽管 302 标准禁止 POST 变换成 GET，但实际使用时大家并不遵守。
- 307 会遵照浏览器标准，不会从 POST 变成 GET。但是，对于处理响应时的行为，每种浏览器有可能出现不同的情况。
9. 400 Bad Request
- 该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。
10. 401 Unauthorized
- 该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。另外若之前已进行过 1 次请求，则表示用户认证失败。
11. 403 Forbidden
- 该状态码表明对请求资源的访问被服务器拒绝了。
12. 404 Not Found 
- 该状态码表明服务器上无法找到请求的资源。
13. 500 Internal Server Error
- 该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。
14. 503 Service Unavailable
- 该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。
- 如果事先得知解除以上状况需要的时间，最好写入 RetryAfter 首部字段再返回给客户端。

## 4 种 HTTP 首部字段类型
1. 通用首部字段（General Header Fields）
- 请求报文和响应报文两方都会使用的首部。
2. 请求首部字段（Request Header Fields）
- 从客户端向服务器端发送请求报文时使用的首部。
- 补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。
3. 响应首部字段（Response Header Fields）
- 从服务器端向客户端返回响应报文时使用的首部。
- 补充了响应的附加内容，也会要求客户端附加额外的内容信息。
4. 实体首部字段（Entity Header Fields）
- 针对请求报文和响应报文的实体部分使用的首部。
- 补充了资源内容更新时间等与实体有关的信息。

## HTTP/1.1 通用首部字段
- 通用首部字段是指，请求报文和响应报文双方都会使用的首部。
1. Cache-Control 
- 通过指定首部字段 Cache-Control 的指令，就能操作缓存的工作机制。
2. Connection 首部字段具备如下两个作用
- 控制不再转发给代理的首部字段
- 管理持久连接，HTTP/1.1 版本的默认连接都是持久连接。
3. Date
- 首部字段 Date 表明创建 HTTP 报文的日期和时间。
4. Pragma
- Pragma 是 HTTP/1.1 之前版本的历史遗留字段，仅作为与 HTTP/1.0的向后兼容而定义。
5. Transfer-Encoding
- 首部字段 Transfer-Encoding 规定了传输报文主体时采用的编码方式。比如chunked
6. Upgrade
- 首部字段 Upgrade 用于检测 HTTP 协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议。
- 不日webSocket 就使用了这个字段

## 请求首部字段
- 请求首部字段是从客户端往服务器端发送请求报文中所使用的字段，用于补充请求的附加信息、客户端信息、对响应内容相关的优先级等内容。
1. Accept
- Accept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。
- 可使用 type/subtype 这种形式，一次指定多种媒体类型。
2. Accept-Charset 字符集
3. Accept-Encoding 
- Accept-Encoding 首部字段用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序。可一次性指定多种内容编码。
...有点多喔

## 响应首部
1. Location 
- 使用首部字段 Location 可以将响应接收方引导至某个与请求 URI 位置不同的资源。
- 基本上，该字段会配合 3xx ：Redirection 的响应，提供重定向的URI。
- 几乎所有的浏览器在接收到包含首部字段 Location 的响应后，都会强制性地尝试对已提示的重定向资源的访问。
...有点多喔

## HTTP缺点
- 窃听，伪装，篡改；
1. 通信使用明文（不加密），内容可能会被窃听
2. 不验证通信方的身份，因此有可能遭遇伪装
3. 无法证明报文的完整性，所以有可能已遭篡改

## HTTPS
### 通信使用明文可能会被窃听
- 在目前大家正在研究的如何防止窃听保护信息的几种对策中，最为普及的就是加密技术。加密的对象可以有这么几个。
1. 一种方式就是将通信加密。
- HTTP 协议中没有加密机制，但可以通过和 SSL（Secure Socket Layer，安全套接层）或TLS（Transport Layer Security，安全层传输协议）的组合使用，加密 HTTP 的通信内容。
- 用 SSL建立安全通信线路之后，就可以在这条线路上进行 HTTP通信了。与 SSL组合使用的 HTTP 被称为 HTTPS（HTTP Secure，超文本传输安全协议）或 HTTP over SSL。
2. 内容的加密
- 还有一种将参与通信的内容本身加密的方式。由于 HTTP 协议中没有加密机制，那么就对 HTTP 协议传输的内容本身加密。即把 HTTP 报文里所含的内容进行加密处理。
- 诚然，为了做到有效的内容加密，前提是要求客户端和服务器同时具备加密和解密机制。
- 主要应用在 Web 服务中。有一点必须引起注意，**由于该方式不同于 SSL或 TLS 将整个通信线路加密处理，所以内容仍有被篡改的风险。**

### 不验证通信方的身份就可能遭遇伪装
- HTTP 协议中的请求和响应不会对通信方进行确认。也就是说存在“服务器是否就是发送请求中 URI 真正指定的主机，返回的响应是否真的返回到实际提出请求的客户端”等类似问题。
- 任何人都可发起请求
- 在 HTTP 协议通信时，由于不存在确认通信方的处理步骤，任何人都可以发起请求。另外，服务器只要接收到请求，不管对方是谁都会返回一个响应（但也仅限于发送端的 IP 地址和端口号没有被 Web 服务器设定限制访问的前提下）。
- HTTP 协议的实现本身非常简单，不论是谁发送过来的请求都会返回响应，因此不确认通信方，会存在以下各种隐患。
1. 无法确定请求发送至目标的 Web 服务器是否是按真实意图返回响应的那台服务器。有可能是已伪装的 Web 服务器。
2. 无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端。有可能是已伪装的客户端。
3. 无法确定正在通信的对方是否具备访问权限。因为某些 Web 服务器上保存着重要的信息，只想发给特定用户通信的权限。
4. 无法判定请求是来自何方、出自谁手。
5. 即使是无意义的请求也会照单全收。无法阻止海量请求下的 DoS 攻击（Denial of Service，拒绝服务攻击）。

- 查明对手的证书
- 虽然使用 HTTP 协议无法确定通信方，但如果使用 SSL则可以。
- SSL不仅提供加密处理，而且还使用了一种被称为证书的手段，可用于确定方。
- 证书由值得信任的第三方机构颁发，用以证明服务器和客户端是实际存在的。
- 另外，伪造证书从技术角度来说是异常困难的一件事。所以只要能够确认通信方（服务器或客户端）持有的证书，即可判断通信方的真实意图。
- 通过使用证书，以证明通信方就是意料中的服务器。这对使用者个人来讲，也减少了个人信息泄露的危险性。
- 另外，客户端持有证书即可完成个人身份的确认，也可用于对 Web 网站的认证环节。

### 无法证明报文完整性，可能已遭篡改
- 就算报文中途被篡改了，或者中间人攻击

### HTTP + 加密 + 认证 + 完整性保护 = HTTPS
- SSL是独立于 HTTP 的协议，所以不光是 HTTP 协议，其他运行在应用层的 SMTP 和 Telnet 等协议均可配合 SSL协议使用。
- 可以说 SSL是当今世界上应用最为广泛的网络安全技术。

### 共享密钥加密的困境（对称加密）
- 以共享密钥方式加密时必须将密钥也发给对方，攻击者可以拿到密钥；
### 使用两把密钥的公开密钥加密（非对称加密）
- 公开密钥加密使用一对非对称的密钥。一把叫做私有密钥 （private key），另一把叫做公开密钥（public key）。
- 顾名思 义，私有密钥不能让其他任何人知道，而公开密钥则可以随意发 布，任何人都可以获得。
- 使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进 行加密处理，对方收到被加密的信息后，再使用自己的私有密钥 进行解密。- 利用这种方式，不需要发送用来解密的私有密钥，也 不必担心密钥被攻击者窃听而盗走。

### HTTPS 采用混合加密机制
- HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密 机制。
- 若密钥能够实现安全交换，那么有可能会考虑仅使用公开 密钥加密来通信。
- 但是公开密钥加密与共享密钥加密相比，其处 理速度要慢。

- 所以应充分利用两者各自的优势，将多种方法组合起来用于通 信。
- 在交换密钥环节使用公开密钥加密方式，之后的建立通信交 换报文阶段则使用共享密钥加密方式。

### 证明公开密钥正确性的证书
- 遗憾的是，公开密钥加密方式还是存在一些问题的。那就是无法证明 公开密钥本身就是货真价实的公开密钥。
- 比如，正准备和某台服务器 建立公开密钥加密方式下的通信时，如何证明收到的公开密钥就是原 本预想的那台服务器发行的公开密钥。
- 或许在公开密钥传输途中，真 正的公开密钥已经被攻击者替换掉了。 
- 为了解决上述问题，可以使用由数字证书认证机构（CA，Certificate Authority）和其相关机关颁发的公开密钥证书。
- 数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的 立场上。

### HTTPS 的安全通信机制
1. 客户端通过发送 Client Hello 报文开始 SSL通信。
- 报文中包 含客户端支持的 SSL的指定版本、加密组件（Cipher Suite）列表（所 使用的加密算法及密钥长度等）。
2. 服务器可进行 SSL通信时，会以 Server Hello 报文作为应答。
- 和客户端一样，在报文中包含 SSL版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。
3. 之后服务器发送 Certificate 报文。
- 报文中包含公开密钥证书。
4. 最后服务器发送 Server Hello Done 报文通知客户端，最初阶 段的 SSL握手协商部分结束。

5. SSL第一次握手结束之后，客户端以 Client Key Exchange 报 文作为回应。
- 报文中包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串。
- 该报文已用步骤 3 中的公开密钥进行加密。
6. 接着客户端继续发送 Change Cipher Spec 报文。
- 该报文会提 示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密。
7. 客户端发送 Finished 报文。
- 该报文包含连接至今全部报文的 整体校验值。
- 这次握手协商是否能够成功，要以服务器是否能够正确 解密该报文作为判定标准。
8. 服务器同样发送 Change Cipher Spec 报文。
9. 服务器同样发送 Finished 报文。
10. 服务器和客户端的 Finished 报文交换完毕之后，SSL连接 就算建立完成。
- 当然，通信会受到 SSL的保护。从此处开始进行应用 层协议的通信，即发送 HTTP 请求。
11. 应用层协议通信，即发送 HTTP 响应。
12. 最后由客户端断开连接。
- 断开连接时，发送 close_notify 报 文。上图做了一些省略，这步之后再发送 TCP FIN 报文来关闭与 TCP 的通信。
- 在以上流程中，应用层发送数据时会附加一种叫做 MAC（Message Authentication Code）的报文摘要。
- MAC 能够查知报文是否遭到篡 改，从而保护报文的完整性。





















